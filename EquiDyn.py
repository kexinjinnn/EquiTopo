'''
Date: May 2022

This file implements the OD/OU-EquiDyn topologies from:
Communication-Efficient Topologies for Decentralized Learning with $\Om(1)$ Consensus Rate.

'''
import numpy as np
import networkx as nx
from itertools import chain
from typing import List, Tuple, Dict, Iterator, Optional

def GetODEquiDynCompleteSendRecvRanks(
        topo: nx.DiGraph, self_rank: int, seed=0) -> Iterator[Tuple[List[int], List[int]]]:
    """A utility function to generate 1-outoging send rank and corresponding recieving rank(s).
        The generating method is OD-EquiDyn with M=n-1.

    Args:
        topo (nx.DiGraph): The base topology to generate dynamic send and receive ranks.
        self_rank (int): The self rank.
        seed: an integer used as the random seed
    Yields:
        Iterator[Tuple[List[int], List[int]]]: send_ranks, recv_ranks.
    """
    n = topo.number_of_nodes()
    rng = np.random.default_rng(seed)
    rank = self_rank + 1
    while True:
        p = int(rng.choice(np.arange(1, n), size=1))
        j = (rank + p) % n
        if j == 0:
            send_rank = n - 1
        else:
            send_rank = j-1
        j = (rank - p) % n
        if j == 0:
            recv_rank = n - 1
        else:
            recv_rank = j-1
        yield [send_rank], [recv_rank]

def GetODEquiDynSendRecvRanks(
        topo: nx.DiGraph, self_rank: int, seed=0, As=None) -> Iterator[Tuple[List[int], List[int]]]:
    """A utility function to generate 1-outoging send rank and corresponding recieving rank(s).
        The generating method is OD-EquiDyn with basis index As.

    Args:
        topo (nx.DiGraph): The base topology to generate dynamic send and receive ranks.
        self_rank (int): The self rank.
        seed: an integer used as the random seed
        As: the basis index generated by D-EquiStatic algorithm.
    Yields:
        Iterator[Tuple[List[int], List[int]]]: send_ranks, recv_ranks.
    """
    n = topo.number_of_nodes()
    rng = np.random.default_rng(seed)
    rank = self_rank + 1
    while True:
        p = int(rng.choice(As, size=1))
        j = (rank + p) % n
        if j == 0:
            send_rank = n - 1
        else:
            send_rank = j-1
        j = (rank - p) % n
        if j == 0:
            recv_rank = n - 1
        else:
            recv_rank = j-1
        yield [send_rank], [recv_rank]

def GetOUEquiDynCompleteSendRecvRanks(
        topo: nx.DiGraph, self_rank: int, seed=0) -> Iterator[Tuple[List[int], List[int]]]:
    """A utility function to generate 1-outoging send rank and corresponding recieving rank(s).
        The generating method is OU-EquiDyn with M=n-1.

    Args:
        topo (nx.DiGraph): The base topology to generate dynamic send and receive ranks.
        self_rank (int): The self rank.
        seed: an integer used as the random seed
    Yields:
        Iterator[Tuple[List[int], List[int]]]: send_ranks, recv_ranks.
    """
    n = topo.number_of_nodes()
    rng = np.random.default_rng(seed)
    while True:
        p = int(rng.choice(np.arange(1, n), size=1))
        s = int(rng.choice(np.arange(1, n + 1), size=1))
        W = np.zeros((n,n))
        z = np.zeros(n)
        # construct the whole topology
        for i in chain(range(int(s), n+1), range(1, int(s))):
            j = (i + p) % n
            if j == 0: j = n
            if z[i-1] == 0 and z[j-1] == 0:
                W[i-1, j-1] = 1
                W[j-1, i-1] = 1
                z[i-1] = 1
                z[j-1] = 1
        if z[self_rank] == 0:
            yield None, None
        else: 
            nhood = W[self_rank]
            idx = np.nonzero(nhood)[0]
            for i in idx:
                if not (i == self_rank):
                    recv_rank = i
                    send_rank = i
            yield [send_rank], [recv_rank]

def GetOUEquiDynSendRecvRanks(
        topo: nx.DiGraph, self_rank: int, seed=0, As=None) -> Iterator[Tuple[List[int], List[int]]]:
    """A utility function to generate 1-outoging send rank and corresponding recieving rank(s).
        The generating method is OU-EquiDyn with basis index As.

    Args:
        topo (nx.DiGraph): The base topology to generate dynamic send and receive ranks.
        self_rank (int): The self rank.
        seed: an integer used as the random seed
        As: the basis index generated by D-EquiStatic algorithm.
    Yields:
        Iterator[Tuple[List[int], List[int]]]: send_ranks, recv_ranks.
    """
    n = topo.number_of_nodes()
    rng = np.random.default_rng(seed)
    while True:
        p = int(rng.choice(As, size=1))
        s = int(rng.choice(np.arange(1, n + 1), size=1))
        W = np.zeros((n,n))
        z = np.zeros(n)
        # construct the whole topology
        for i in chain(range(int(s), n+1), range(1, int(s))):
            j = (i + p) % n
            if j == 0: j = n
            if z[i-1] == 0 and z[j-1] == 0:
                W[i-1, j-1] = 1
                W[j-1, i-1] = 1
                z[i-1] = 1
                z[j-1] = 1
        if z[self_rank] == 0:
            yield None, None
        else: 
            nhood = W[self_rank]
            idx = np.nonzero(nhood)[0]
            for i in idx:
                if not (i == self_rank):
                    recv_rank = i
                    send_rank = i
            yield [send_rank], [recv_rank]
